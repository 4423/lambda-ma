  module F = functor (M: sig end) ->
    (struct
      type t = int
      let zero = 0
      let f = fun x -> zero
    end
    :
    sig
      type t
      val zero: t
      val f: t -> t
    end)

  module Empty = struct end
  module Empty2 = struct end
  
  module C = F (struct end)
  module A = F (Empty)
  module B = F (Empty)
  module E = F (Empty2)
  
  let test4 = A.f A.zero
  let test5 = A.f B.zero
  (* let test6 = A.f C.zero *)
  (* let test7 = A.f E.zero *)

  module G = functor (X: sig type t end) ->
    struct 
      type t = X.t -> X.t 
    end

  module L = G(struct type t = int end)

  module Apply = functor (F: functor (X: sig type t end) -> sig type t end) ->
                    functor(A: sig type t end) -> F(A)
  module Identity = functor(X: sig type t end) -> X
  module Int = struct type t = int end
  module Hi = Apply(Identity)(Int)

let fib = 
  let rec f = fun n -> 
    if n < 3 then 1
    else f (n-1) + f (n-2)
  in f

let rec f = fun n -> 
  if n < 3 then 1
  else f (n-1) + f (n-2)

let c1 = .<1+2>.
let c2 = .<.~c1>.
let c3 = Runcode.run c1
let c4 = Runcode.run (let a = ((fun x -> .<1>.) 0) in a)
let c5 = .<.~( (fun x -> .<1>.) 0 )>.

type u = int code
module C1 = .<< struct 
  type t = int
  type v = .%u
  let f = fun x -> x + 10
end >>.
module C2 = .<< .~~C1 >>.
module C3 = Runmod(C1 : sig end)

(* don't allow definition and application of functor at level 1
module C4 = .<< struct
  module F = functor(X: sig end) -> X
  module A = F(struct end)
end >>.
*)

module C5 = functor(X : sig end mcod) -> X
module C6 = .<< struct end >>.
module C7 = C5(C6)
module C8 = .<< .~~( (functor(X : sig end mcod) -> X) (.<< struct end >>.) ) >>.

module C9 = .<< (struct
  type t = int
  let x = 0
  let y = x
  module A = struct let x = 1 end
  let z = A.x
end : sig 
  type t
  val x : int
  val y : t
end) >>.

let s1 = "str"
type s2 = string
let b1 = true
let b2 = false
type b3 = bool

module D1 = struct
  module A = struct
    module B = .<< struct
      module C = struct
        module D = (struct
          type t = int
          let x = 0
        end : sig
          type t = int
          val x: t
        end)
      end
      type u = int
      let y = 0
    end >>.
    type v = B$u
    let z = B$y
  end
end
let d1 = D1.A.B$y
type d2 = D1.A.B$u
module D2 = D1.A.B$C
module D3 = D2$D
let d3 = D3$x
type d4 = D3$t
let d5 = Runcode.run (D3$x)
let d6 = d5 + 1

let m1 = fun xs -> match xs with a::b -> let z = a + 1 in a
let m2 = fun xs -> match xs with (a1,(a2,a3))::b -> b | c -> c | _ -> xs