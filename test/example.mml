  module F = functor (M: sig end) ->
    (struct
      type t = int
      let zero = 0
      let f = fun x -> zero
    end
    :
    sig
      type t
      val zero: t
      val f: t -> t
    end)

  module Empty = struct end
  module Empty2 = struct end
  
  module C = F (struct end)
  module A = F (Empty)
  module B = F (Empty)
  module E = F (Empty2)
  
  let test4 = A.f A.zero
  let test5 = A.f B.zero
  (* let test6 = A.f C.zero *)
  (* let test7 = A.f E.zero *)

  module G = functor (X: sig type t end) ->
    struct 
      type t = X.t -> X.t 
    end

  module L = G(struct type t = int end)

  module Apply = functor (F: functor (X: sig type t end) -> sig type t end) ->
                    functor(A: sig type t end) -> F(A)
  module Identity = functor(X: sig type t end) -> X
  module Int = struct type t = int end
  module Hi = Apply(Identity)(Int)

let fib = 
  let rec f = fun n -> 
    if n < 3 then 1
    else f (n-1) + f (n-2)
  in f

let rec f = fun n -> 
  if n < 3 then 1
  else f (n-1) + f (n-2)

let c1 = .<1+2>.
let c2 = .<.~c1>.
let c3 = Runcode.run c1
let c4 = Runcode.run (let a = ((fun x -> .<1>.) 0) in a)
let c5 = .<.~( (fun x -> .<1>.) 0 )>.

type u = int code
module C1 = .<< struct 
  type t = int
  type v = .%u
  let f = fun x -> x + 10
end >>.
module C2 = .<< .~~C1 >>.
module C3 = Runmod(C1 : sig end)

(* don't allow definition and application of functor at level 1
module C4 = .<< struct
  module F = functor(X: sig end) -> X
  module A = F(struct end)
end >>.
*)